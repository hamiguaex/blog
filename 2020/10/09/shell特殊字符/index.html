<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
<link rel="stylesheet" href="/blog/style/main.css">
<link rel="stylesheet" href="/blog/style/header.css">
<link rel="stylesheet" href="/blog/style/container.css">
<link rel="stylesheet" href="/blog/style/footer.css">
<link rel="stylesheet" href="/blog/style/pagination.css">
<link rel="stylesheet" href="/blog/style/iconfont.css">
<link rel="stylesheet" href="/blog/style/more.css">
<link rel="stylesheet" href="/blog/style/article.css">

    
<script src="/blog/js/indexmenu.js"></script>
<script src="/blog/js/jumptop.js"></script>
<script src="/blog/js/index.js"></script>

    <title>
        Hello My Tomorrow——Han&#39;s blog
    </title>
<meta name="generator" content="Hexo 5.2.0"></head>
    <body><header id="top">
    <a href="/blog/">
        <div id="logo">
            <div class="logo-title">Hello My Tomorrow</div>
            <div class="logo-tips">Han's Blog</div>
        </div>
    </a>
    <div id="menu">
        <div id="menu-button">menu<i class="icon-menu"></i></div>
        <ul>
            
            <li><a href="/blog/">Home</a></li>
            
            <li><a href="/blog/archives">Archives</a></li>
            
            <li><a href="/blog/categories">Categories</a></li>
            
            <li><a href="/blog/about-me">About me</a></li>
            
            <!-- <li><a href="#">home</a></li> -->
            <!-- <li><a href="#">blog</a></li> -->
            <!-- <li><a href="#">categories</a></li> -->
            <!-- <li><a href="#">about me</a></li> -->
        </ul>
    </div>
    <div id="footer">
        <div>© 2020 HanMingtao</div>
        <div>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></div>
    </div>
</header>


    
        













































































<div id="listtitle-box">
<div class="listtitle">
    <h1><span>Shell特殊字符</span></h1>
    <div class="articleinfo">
        <div class="date">
             
                2020-10-9
             
        </div>
    </div>
</div>
</div>
        <div id="container" class="container-width">
            <div class="article-item">
    <ul>
<li><p><strong>注释</strong> 行首以#(#!是个例外)开头的是注释</p>
<ul>
<li>注释也可以放在命令后面</li>
<li>注释也可以放在空白后面(注释不用顶格写)</li>
<li>标准的引用和转义字符(“ ‘ \)可以用来转义#</li>
<li>某些特定的模式匹配操作也可以使用#</li>
</ul>
</li>
<li><p><strong>命令分隔符[分号(;)]</strong> 可以在同一行上写两个或两个以上的命令</p>
</li>
<li><p><strong>终止case选项[双分号(;;)]</strong></p>
</li>
<li><p><strong>“点”命令[句点(.)]</strong> 等价于source命令, 这是一个bash的内建命令</p>
</li>
<li><p><strong>“点”作为文件名的一部分</strong> 点放在文件名的开头, 这个文件爱你将会成为隐藏文件</p>
</li>
<li><p><strong>“点”作为目录名</strong></p>
<ul>
<li>一个点代表当前的工作目录</li>
<li>两个点代表上一级目录</li>
</ul>
</li>
<li><p><strong>“点”字符匹配</strong> 当用作匹配字符的作用是, 通常都是作为正则表达式的一部分来使用, “点”用来匹配任意的单个字符</p>
</li>
<li><p><strong>部分引用[双引号(“)]</strong> “STRING”将会阻止解释STRING中的大部分特殊字符</p>
</li>
<li><p><strong>全引用[单引号(‘)]</strong> ‘STRING’将会阻止STRING中的所有特殊字符的解释</p>
</li>
<li><p><strong>逗号操作符(,)</strong> 逗号操作符连接了一系列的算术操作, 虽然里边所有的内容都被运行了, 但只有最后一项被返回</p>
</li>
<li><p><strong>转义符[反斜线(\)]</strong> 一种对单字符的引用机制</p>
<ul>
<li>\X将会转义字符X, 等价于”X”或’X’, \通常用开转义(“)和(‘), 这样双引号和单引号就不会被解释成特殊含义了</li>
</ul>
</li>
<li><p><strong>[斜线(/)]</strong></p>
<ul>
<li>文件名路径分隔符, 分隔文件名的不同部分(home/aaa/bbb)</li>
<li>用作除法算术操作</li>
</ul>
</li>
<li><p>**命令替换(<code>)** \</code>command`结构可以将命令的输出赋值到一个变量中去</p>
</li>
<li><p><strong>[冒号(:)]</strong> </p>
<ul>
<li><p>空命令, 等价于”NOP”(no op, 一个什么也不干的命令)</p>
</li>
<li><p>也可以被认为与shell的内建命令true作用相同(“:”命令是一个bash的内建命令, 它的退出码(exit status)是”true”(0))</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:</span><br><span class="line">echo $?		# 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>死循环</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">	operation-1</span><br><span class="line">	...</span><br><span class="line">	operation-n</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价于</span></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">	...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li><p>在if/then中的占位符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then :		# 什么都不作, 引出分支</span><br><span class="line">else</span><br><span class="line">	take-some-action</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个二元命令中提供一个占位符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: $&#123;username=`whoami`&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$&#123;username=`whoami`&#125;</span>		如果没有开头的<span class="string">&quot;:&quot;</span>话, 将会给出一个错误, 除非<span class="string">&quot;username&quot;</span>是一个命令或者内建命令...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在here document中提供一个命令所需的占位符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: $&#123;HOSTNAME?&#125; $&#123;USER?&#125; $&#123;MAIL?&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果一个或多个必要的环境变量没被设置的话, 就打印错误信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量扩展/子串替换</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;var:pos&#125;	<span class="comment">#变量var从位置pos开始扩展(pos之前的字符都丢弃)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;var:pos:len&#125;	<span class="comment">#变量var从位置pos开始, 并扩展len个字符</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在与&gt;重定向操作符结合使用时, 将会把一个文件清空, 但是并不会修改这个文件的权限, 如果之前这个文件并不存在, 将会创建这个文件</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">: &gt; data.xxx	# 文件&quot;data.xxx&quot;被清空</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 与cat /dev/null &gt;dataxxx的作用相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然而, 这并不会产生一个新的进程, 因为<span class="string">&quot;:&quot;</span>是一个内建命令</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在与&gt;&gt;重定向操作符结合使用时, 将不会对预先存在的目标文件(: &gt;&gt; target_file)产生任何影响, 如果这文件不存在, 将会创建这个文件(只适用于正规文件, 而不适用于管道, 符号连接, 和某些特殊文件)</p>
</li>
<li><p>也可以用来作注释行(不推荐)</p>
<ul>
<li><p>使用#开注释, 将关闭对该行其余部分的错误检查, 所以可以在注释行中写任何东西. 使用:的话将不会这样</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: This is a comment that generates an error, ( if [ $x -eq 3] ).</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>“:”还用于在/etc/passwd和$PATH变量中作分隔符</p>
</li>
</ul>
</li>
<li><p><strong>[叹号(!)]</strong>  </p>
<ul>
<li>取反操作符, 返回反转的命令的退出码的结果, 也会反转操作符的意义(!=)</li>
<li>在不同的上下文中, 用于变量的间接引用</li>
<li>在命令命令行模式下, 调用bash的历史记录机制, 脚本中历史机制被禁用</li>
</ul>
</li>
<li><p>*<em>[星号(</em>)]** </p>
<ul>
<li>算术操作符, 乘法运算</li>
<li>求幂操作符(**)</li>
</ul>
</li>
<li><p><strong>[问号(?)]</strong></p>
<ul>
<li><p>测试操作符, 在特定表达式中, ?用来测试一个条件的结果</p>
</li>
<li><p>在双括号结构中, ?就是C语言的三元操作符</p>
</li>
<li><p>在参数替换表达式中, ?用来测试一个变量是否被set了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter?err_msg&#125;	<span class="comment"># 如果parameter已经被声明, 那么就使用设置的值, 否则打印err_msg错误消息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter:?err_msg&#125;	<span class="comment"># 如果parameter已经被设置, 那么就使用设置的值, 否则打印err_msg错误消息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这两种形式在大多数情况是一样的, 只有在parameter被声明并设置为null值的时候, 多出来的:才会引起这两种形式的不同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 有:的, 即使parameter被设置为null, 也会打印错误消息</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通配符, ?在通配(globbing)中, 用来匹配单个字符; 在正则表达式中, 也是用来表示一个字符</p>
</li>
</ul>
</li>
<li><p><strong>[美元($)]</strong></p>
<ul>
<li>变量替换(引用变量的内容), 在一个变量前面加上$用来引用这个变量的值</li>
<li>行结束符, 在正则表达式中, $表示行结束</li>
<li>参数替换, ${}</li>
<li>位置参数, $*, $@</li>
<li>退出状态码变量, $?, 保存一个命令, 一个函数, 或者脚本的退出状态码</li>
<li>进程ID变量, $$, 保存了它所在见本的进程ID</li>
</ul>
</li>
<li><p><strong>[括号(())]</strong></p>
<ul>
<li><p>命令组, 在括号中的命令列表,       将会作为一个<strong>子shell</strong>来运行. 在括号中的变量, 由于是在子shell中, 所以对于脚本剩下的部分是不可用的. 父进程, 也就是脚本本身, 将不能够读取在子进程中创建的变量, 也就是在子shell中创建的变量. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a=hello; echo $a)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=123</span><br><span class="line">( a=321; )</span><br><span class="line">echo &quot;a = $a&quot;	#a = 123</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在圆括号中a变量, 更像是一个局部变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化数组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array=(element1 element2 element3)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>[大括号({})]</strong></p>
<ul>
<li><p>大括号扩展, {xxx, yyy, zzz, …}, 一个命令可能会对大括号中的以逗号分隔的文件列表其作用. 通配将对大括号中的文件名做扩展</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &#123;file1,file2,file3&#125; &gt; combined_file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把file1, file2, file3连接在一起, 并重定向到combined_file中</span></span><br><span class="line"></span><br><span class="line">cp file22.&#123;txt,backup&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝<span class="string">&quot;file22.txt&quot;</span>到<span class="string">&quot;file22.backup&quot;</span>中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在大括号中不允许有空白, 除非这个空白被引用或转义</span></span><br><span class="line">echo &#123;file1,file2&#125;\ :&#123;\ A,&quot; B&quot;,&#x27; C&#x27;&#125;</span><br><span class="line"></span><br><span class="line">file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码块, 又被称为<em>内部组</em>, 这个结构事实上创建了一个匿名函数(一个没有名字的函数). 然而, 与”标准”函数不同的是, 在其中声明的变量,对于脚本其他部分的代码来说还是可见的. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">bash$</span><span class="bash"> &#123; <span class="built_in">local</span> a;</span></span><br><span class="line">       a=123; &#125;</span><br><span class="line">bash: local: can only be used in a function</span><br><span class="line"></span><br><span class="line">a=123</span><br><span class="line">&#123; a=321; &#125;</span><br><span class="line">echo &quot;a = $a&quot;   # a = 321   (说明在代码块中对变量a所作的修改, 影响了外边的变量)</span><br></pre></td></tr></table></figure>
</li>
<li><p>{} ;路径名. 一般都在find命令中使用. 这不是一个shell内建命令.(“;”用来结束find命令序列的-exec选项. 它需要被保护以防止被shell所解释. )</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>中括号[[]]</strong></p>
<ul>
<li><p>条件测试, 条件测试表达式放在**[ ]<strong>中, 值得注意的是</strong>[<strong>是shell内建</strong>test**命令的一部分,  并不是/usr/bin/test中的外部命令的一个链接.</p>
</li>
<li><p>[[ ]], 测试, 测试表达式放在[[ ]]中. </p>
</li>
<li><p>[ ], 数组元素, 在一个array结构的上下文中,        中括号用来引用数组中每个元素的编号.           </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array[1]=slot_1</span><br><span class="line">echo $&#123;Array[1]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[ ], <strong>字符范围.</strong> 用作[正则表达式]的一部分,         方括号描述一个匹配的[字符范围]</p>
</li>
</ul>
</li>
<li><p><strong>双括号[(( ))]</strong></p>
</li>
<li><p><strong>整数扩展.</strong> 扩展并计算在(( ))中的整数表达式. </p>
</li>
<li><p><strong>&gt; &amp;&gt; &gt;&amp; &gt;&gt; &lt; &lt;&gt;</strong></p>
<ul>
<li><p>重定向,  &gt;filename          重定向<code>scriptname</code>的输出到文件<code>filename</code>中.          如果<code>filename</code>存在的话, 那么将会被覆盖. </p>
</li>
<li><p>command &amp;&gt;filename          重定向<code>command</code>的<code>stdout</code>和<code>stderr</code>到<code>filename</code>中. </p>
</li>
<li><p>command &gt;&amp;2 重定向<code>command</code>的<code>stdout</code>到<code>stderr</code>中. </p>
</li>
<li><p>scriptname &gt;&gt;filename          把<code>scriptname</code>的输出追加到文件<code>filename</code>中.          如果<code>filename</code>不存在的话,        将会被创建. </p>
</li>
<li><p>[i]&lt;&gt;filename         打开文件<code>filename</code>用来读写,          并且分配[文件描述符]i给这个文件.          如果<code>filename</code>不存在, 这个文件将会被创建. </p>
</li>
<li><p>**进程替换</p>
<ul>
<li>(command)&gt;</li>
<li>command)</li>
</ul>
</li>
<li><p>[在一种不同的上下文中],         “&lt;”和”&gt;”可用来做         [字符串比较操作]. </p>
</li>
<li><p>[在另一种上下文中],         “&lt;”和”&gt;”可用来做         [整数比较操作].</p>
</li>
<li><p><strong>&lt;&lt;**</strong>用在[here document]中的重定向.** </p>
</li>
<li><p><strong>&lt;&lt;&lt;**</strong>用在[here string]中的重定向.** </p>
</li>
<li><p><strong>&lt;, &gt;**</strong>[ASCII         comparison].** </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">veg1=carrots</span><br><span class="line">veg2=tomatoes</span><br><span class="line"></span><br><span class="line">if [[ &quot;$veg1&quot; &lt; &quot;$veg2&quot; ]]</span><br><span class="line">then</span><br><span class="line">	echo &quot;Although $veg1 precede $veg2 in the dictionary,&quot;</span><br><span class="line">	echo &quot;this implies nothing about my culinary preferences.&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;What kind of dictionary are you using, anyhow?&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&lt;, &gt;**</strong>[正则表达式]中的[单词边界]           .** </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">bash$</span><span class="bash"> grep <span class="string">&#x27;\&lt;the\&gt;&#x27;</span> textfile</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>|**</strong>管道.** 分析前边命令的输出,            并将输出作为后边命令的输入.            这是一种产生命令链的好方法. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo ls -l | sh</span><br><span class="line"><span class="meta">#</span><span class="bash">  传递<span class="string">&quot;echo ls -l&quot;</span>的输出到shell中,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">+ 与一个简单的<span class="string">&quot;ls -l&quot;</span>结果相同.</span></span><br><span class="line"></span><br><span class="line">cat *.lst | sort | uniq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并和排序所有的<span class="string">&quot;.lst&quot;</span>文件, 然后删除所有重复的行. </span></span><br></pre></td></tr></table></figure>

<p>管道是进程间通讯的一个典型办法,              将一个进程的<code>stdout</code>放到另一个进程的<code>stdin</code>中.        标准的方法是将一个一般命令的输出,        比如[cat]或者[echo], 传递到一个       “过滤命令”(在这个过滤命令中将处理输入)中, 然后得到结果.          cat $filename1 $filename2 | grep $search_word            </p>
<p>当然输出的命令也可以传递到脚本中.            </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> uppercase.sh : 修改输入, 全部转换为大写. </span></span><br><span class="line"></span><br><span class="line">tr &#x27;a-z&#x27; &#x27;A-Z&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">  字符范围必须被<span class="string">&quot;&quot;</span>引用起来来阻止产生单字符的文件名.</span></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>现在让我们输送<strong>ls -l</strong>的输出到一个脚本中.            </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">bash$</span><span class="bash"> ls -l | ./uppercase.sh -RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE       </span></span><br></pre></td></tr></table></figure>

<p>管道中的每个进程的<code>stdout</code>比须被下一个进程作为<code>stdin</code>来读入.           否则, 数据流会<em>阻塞</em>,           并且管道将产生一些非预期的行为.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 | ls -l | sort</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从<span class="string">&quot;cat file1 file2&quot;</span>中的输出并没出现. </span></span><br></pre></td></tr></table></figure>
<p>作为[子进程]的运行的管道,               不能够改变脚本的变量.          </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable=&quot;initial_value&quot;</span><br><span class="line">echo &quot;new_value&quot; | read variable</span><br><span class="line">echo &quot;variable = $variable&quot;     # variable = initial_value</span><br></pre></td></tr></table></figure>
<p>如果管道中的某个命令产生了一个异常,并中途失败,那么这个管道将过早的终止.          这种行为被叫做<em>broken pipe</em>,           并且这种状态下将发送一个<em>SIGPIPE</em> [信号].</p>
</li>
<li><p><strong>&gt;|**</strong>强制重定向(即使设置了[noclobber选项]     – 就是-C选项).** 这将强制的覆盖一个现存文件. </p>
</li>
<li><p><strong>||**</strong>[或-逻辑操作].** 在一个[条件测试结构]中,              如果条件测试结构两边中的<em>任意一边</em>结果为true的话,              ||操作就会返回0(代表执行成功).          </p>
</li>
<li><p><strong>&amp;**</strong>后台运行命令.** 一个命令后边跟一个&amp;         表示在后台运行. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">bash$</span><span class="bash"> sleep 10 &amp;</span></span><br><span class="line">[1] 850</span><br><span class="line">[1]+  Done                    sleep 10       </span><br></pre></td></tr></table></figure>

<p>在一个脚本中,命令和[循环]都可能运行在后台. </p>
<p>在一个脚本内后台运行一个命令,有可能造成这个脚本的挂起,等待一个按键         响应. 幸运的是, 我们有针对这个问题的[解决办法]. </p>
</li>
</ul>
<ul>
<li><p><strong>&amp;&amp;**</strong>[与-逻辑操作].** 在一个[条件测试结构]中,          只有在条件测试结构的<em>两边</em>结果都为true的时候,          &amp;&amp;操作才会返回0(代表sucess).      </p>
</li>
<li><p><strong>-**</strong>选项, 前缀.** 在所有的命令内如果想使用选项参数的话,前边都要加上”-“. </p>
<p>COMMAND -[Option1][Option2][…]</p>
<p>ls -al</p>
<p>sort -dfu $filename</p>
<p>set – $variable</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if [ $file1 -ot $file2 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;File $file1 is older than $file2.&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$a&quot; -eq &quot;$b&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;$a is equal to $b.&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$c&quot; -eq 24 -a &quot;$d&quot; -eq 47 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;$c equals 24 and $d equals 47.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>-**</strong>用于重定向<code>stdin</code>或<code>stdout</code>[破折号, 即-].** </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 从一个目录移动整个目录树到另一个目录  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [感谢Alan Cox &lt;a.cox@swansea.ac.uk&gt;, 走出了部分修改]  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 1) <span class="built_in">cd</span> /<span class="built_in">source</span>/directory    源目录  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) &amp;&amp;                     <span class="string">&quot;与列表&quot;</span>: 如果<span class="string">&#x27;cd&#x27;</span>命令成功了, 那么就执行下边的命令.   </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3) tar cf - .              <span class="string">&#x27;c&#x27;</span>创建一个新文档, <span class="string">&#x27;f&#x27;</span>后边跟<span class="string">&#x27;-&#x27;</span>指定目标文件作为stdout  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">                            <span class="string">&#x27;-&#x27;</span>后边的<span class="string">&#x27;f&#x27;</span>(file)选项, 指明作为stdout的目标文件.   </span></span><br><span class="line"><span class="meta">#</span><span class="bash">                            并且在当前目录(<span class="string">&#x27;.&#x27;</span>)执行. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4) |                       管道... </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5) ( ... )                 一个子shell </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6) <span class="built_in">cd</span> /dest/directory      改变当前目录到目标目录. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7) &amp;&amp;                     <span class="string">&quot;与列表&quot;</span>, 同上 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8) tar xpvf -              <span class="string">&#x27;x&#x27;</span>解档, <span class="string">&#x27;p&#x27;</span>保证所有权和文件属性, </span></span><br><span class="line"><span class="meta">#</span><span class="bash">                            <span class="string">&#x27;v&#x27;</span>发完整消息到stdout, </span></span><br><span class="line"><span class="meta">#</span><span class="bash">                            <span class="string">&#x27;f&#x27;</span>后边跟<span class="string">&#x27;-&#x27;</span>,从stdin读取数据.  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">                            注意:<span class="string">&#x27;x&#x27;</span> 是一个命令, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;f&#x27;</span> 是选项. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Whew! </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 更优雅的写法应该是: </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   <span class="built_in">cd</span> <span class="built_in">source</span>/directory </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   tar cf - . | (<span class="built_in">cd</span> ../dest/directory; tar xpvf -) </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">     当然也可以这么写: </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp -a /<span class="built_in">source</span>/directory/* /dest/directory </span></span><br><span class="line"><span class="meta">#</span><span class="bash">     或者: </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp -a /<span class="built_in">source</span>/directory/* /<span class="built_in">source</span>/directory/.[^.]* /dest/directory </span></span><br><span class="line"><span class="meta">#</span><span class="bash">     如果在/<span class="built_in">source</span>/directory中有隐藏文件的话.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -  </span><br><span class="line"><span class="meta">#</span><span class="bash">  --未解压的tar文件--    | --然后把它传递到<span class="string">&quot;tar&quot;</span>中--  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">  如果 <span class="string">&quot;tar&quot;</span> 没能够正常的处理<span class="string">&quot;bunzip2&quot;</span>, 这就需要使用管道来执行2个单独的步骤来完成它.  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">  这个练习的目的是解档<span class="string">&quot;bzipped&quot;</span>的kernel源文件.</span></span><br></pre></td></tr></table></figure>

<p>注意, 在这个上下文中”-“本身并不是一个Bash操作,  而是一个可以被特定的UNIX工具识别的选项,  这些特定的UNIX工具特指那些可以写输出到<code>stdout</code>的工具,      比如<strong>tar</strong>, <strong>cat</strong>, 等等.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">bash$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;whatever&quot;</span> | cat - whatever </span></span><br></pre></td></tr></table></figure>

<p>在需要一个文件名的位置,          <code>*-*</code>重定向输出到<code>stdout</code>(有时候会在tar和cf中出现),          或者从<code>stdin</code>接受输入, 而不是从一个文件中接受输入.          这是在管道中使用文件导向(file-oriented)工具来作为过滤器的一种方法. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">bash$</span><span class="bash"> file Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...       </span></span><br></pre></td></tr></table></figure>

<p>在命令行上单独给出一个[file], 会给出一个错误信息.     </p>
<p>添加一个”-“将得到一个更有用的结果.          这会使shell等待用户输入.           </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">bash$</span><span class="bash"> file - abc standard input:              ASCII text  bash$ file - <span class="comment">#!/bin/bash standard input:              Bourne-Again shell script text executable       </span></span></span><br></pre></td></tr></table></figure>

<p>现在命令从<code>stdin</code>中接受了输入, 并分析它.</p>
<p>“-“可以被用来将<code>stdout</code>通过管道传递到其他命令中.          这样就允许使用[在一个文件开头添加几行]的技巧. </p>
<p>使用[diff]命令来和另一个文件的<em>某一段</em>进行比较: </p>
<p>grep Linux file1 | diff file2 -</p>
<p>最后, 来展示一个使用<code>*-*</code>的[tar]命令的一个真实的例子.</p>
<p><strong>例子 3-4. 备份最后一天所有修改的文件</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash">  在一个<span class="string">&quot;tarball&quot;</span>中(经过tar和gzip处理过的文件)  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">+ 备份最后24小时当前目录下d所有修改的文件.   </span></span><br><span class="line">  </span><br><span class="line">BACKUPFILE=backup-$(date +%m-%d-%Y)  </span><br><span class="line"><span class="meta">#</span><span class="bash">                 在备份文件中嵌入时间.  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">                 Thanks, Joshua Tschida, <span class="keyword">for</span> the idea.  </span></span><br><span class="line">archive=$&#123;1:-$BACKUPFILE&#125; </span><br><span class="line"><span class="meta">#</span><span class="bash">  如果在命令行中没有指定备份文件的文件名, </span></span><br><span class="line"><span class="meta">#</span><span class="bash">+ 那么将默认使用<span class="string">&quot;backup-MM-DD-YYYY.tar.gz&quot;</span>. </span></span><br><span class="line"> </span><br><span class="line">tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.tar </span><br><span class="line">gzip $archive.tar </span><br><span class="line">echo &quot;Directory $PWD backed up in archive file \&quot;$archive.tar.gz\&quot;.&quot; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">  Stephane Chazelas指出上边代码, </span></span><br><span class="line"><span class="meta">#</span><span class="bash">+ 如果在发现太多的文件的时候, 或者是如果文件 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">+ 名包括空格的时候, 将执行失败. </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Stephane Chazelas建议使用下边的两种代码之一: </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ------------------------------------------------------------------- </span></span><br><span class="line"><span class="meta">#</span><span class="bash">   find . -mtime -1 -<span class="built_in">type</span> f -print0 | xargs -0 tar rvf <span class="string">&quot;<span class="variable">$archive</span>.tar&quot;</span> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">      使用gnu版本的<span class="string">&quot;find&quot;</span>. </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">   find . -mtime -1 -<span class="built_in">type</span> f -<span class="built_in">exec</span> tar rvf <span class="string">&quot;<span class="variable">$archive</span>.tar&quot;</span> <span class="string">&#x27;&#123;&#125;&#x27;</span> \; </span></span><br><span class="line"><span class="meta">#</span><span class="bash">         对于其他风格的UNIX便于移植, 但是比较慢. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ------------------------------------------------------------------- </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>   ![Caution] 以”-“开头的文件名在使用”-“作为重定向操作符的时候,              可能会产生问题. 应该写一个脚本来检查这个问题, 并给这个文件加上合适的前缀.        比如: <code>./-FILENAME</code>,        <code>$PWD/-FILENAME</code>, 或者        <code>$PATHNAME/-FILENAME</code>. 如果变量以<code>*-*</code>开头进行命名, 可能也会引起问题.      </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;-n&quot;</span><br><span class="line">echo $var</span><br><span class="line"><span class="meta">#</span><span class="bash"> 具有<span class="string">&quot;echo -n&quot;</span>的效果了,这样什么都不会输出的. </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>-**</strong>先前的工作目录.** **cd -**将会回到先前的工作目录. 它使用了[$OLDPWD] [环境变量].</p>
<p>![Caution] 不要混淆这里所使用的”-“和先前我们所讨论的”-“重定向操作符.      对于”-“的具体解释只能依赖于具体的上下文. </p>
</li>
<li><p><strong>-**</strong>减号.** 减号属于[算术操作]. </p>
</li>
<li><p><strong>=**</strong>等号.** [赋值操作]         </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=28</span><br><span class="line">echo $a   # 28</span><br></pre></td></tr></table></figure>

<p>在[另一种上下文环境中],       “=”也用来做[字符串比较]操作. </p>
</li>
<li><p><strong>+**</strong>加号.** 加法[算术操作]. </p>
<p>在[另一种上下文环境中],        +也是一种[正则表达式]操作. </p>
</li>
<li><p><strong>+**</strong>选项.** 一个命令或者过滤器的选项标记. </p>
<p>某些命令[内建命令]使用+来打开特定的选项,         用-来禁用这些特定的选项. </p>
</li>
<li><p><strong>%**</strong>[取模].** 取模(一次除法的余数)[算术操作],        %也是一种[模式匹配]操作. </p>
</li>
<li><p><strong>~**</strong>home目录[波浪号, 即<del>].** 相当于[$HOME]内部变量.           *</del>bozo*是bozo的home目录,     并且<strong>ls ~bozo</strong>将列出其中的内容.     ~/就是当前用户的home目录,     并且**ls ~/**将列出其中的内容.            </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">bash$</span><span class="bash"> <span class="built_in">echo</span> ~bozo /home/bozo bash$ <span class="built_in">echo</span> ~ /home/bozo bash$ <span class="built_in">echo</span> ~/ /home/bozo/ bash$ <span class="built_in">echo</span> ~: /home/bozo: bash$ <span class="built_in">echo</span> ~nonexistent-user ~nonexistent-user       </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>~+**</strong>当前工作目录.** 相当于[$PWD]内部变量. </p>
</li>
<li><p><strong>~-**</strong>先前的工作目录.** 相当于[$OLDPWD]内部变量. </p>
</li>
<li><p><strong>=~**</strong>[正则表达式匹配].** 这个操作将会在[version 3]版本的Bash部分进行讲解. </p>
</li>
<li><p><strong>^**</strong>行首.** 在[正则表达式]中,          “^”表示定位到文本行的行首. </p>
</li>
<li><p><strong>控制字符</strong>, <strong>修改终端或文本显示的行为. .</strong> 控制字符以<strong>CONTROL</strong>       + <strong>key</strong>这种方式进行组合(同时按下).               控制字符也可以使用<em>8进制</em>或<em>16进制</em>表示法来进行表示,        但是前边必须要加上<em>转义符</em>. </p>
<p>控制字符在脚本中不能正常使用. </p>
<ul>
<li><p>Ctl-B退格(非破坏性的), 就是退格但是不删掉前面的字符.</p>
</li>
<li><p>Ctl-Cbreak. 终结一个前台作业.</p>
</li>
<li><p>Ctl-D从一个shell中登出(与[exit]很相像). “EOF”(文件结束).          这也能从<code>stdin</code>中终止输入. 在console或者在<em>xterm</em>窗口中输入的时候,                  Ctl-D将删除光标下字符.                  当没有字符时, Ctl-D将退出当前会话,        在一个xterm窗口中, 则会产生关闭此窗口的效果. </p>
</li>
<li><p>Ctl-G”哔” (beep). 在一些老式的打字机终端上, 它会响一下铃. </p>
</li>
<li><p>Ctl-H”退格”(破坏性的), 就是在退格之后, 还要删掉前边的字符. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Embedding Ctl-H <span class="keyword">in</span> a string.</span></span><br><span class="line">a=&quot;^H^H&quot;                  # 两个 Ctl-H&#x27;s (backspaces).</span><br><span class="line">echo &quot;abcdef&quot;             # abcdef</span><br><span class="line">echo -n &quot;abcdef$a &quot;       # abcd f</span><br><span class="line"><span class="meta">#</span><span class="bash">  Space at end  ^              ^ 两次退格.</span></span><br><span class="line">echo -n &quot;abcdef$a&quot;        # abcdef</span><br><span class="line"><span class="meta">#</span><span class="bash">  结尾没有空格                   没有 backspace 的效果了(why?).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结果并不像期望的那样.</span></span><br><span class="line">echo; echo</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ctl-I水平制表符.</p>
</li>
<li><p>Ctl-J重起一行(换一行并到行首). 在脚本中, 也可以使用8进制表示法              – ‘\012’ 或者16进制表示法 – ‘\x0a’ 来表示. </p>
</li>
<li><p>Ctl-K垂直制表符.当在console或者<em>xterm</em>窗口中输入文本时,                  Ctl-K将会删除从光标所在处到行为的全部字符.                  在脚本中, Ctl-K的行为有些不同,        具体请参见下边的Lee Maschmeyer的例子程序. </p>
</li>
<li><p>Ctl-L清屏(清除终端的屏幕显示). 在终端中,         与[clear]命令的效果相同.          当发送到打印机上时, Ctl-L会让打印机将打印纸卷到最后. </p>
</li>
<li><p>Ctl-M回车.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">  #</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Thank you, Lee Maschmeyer, <span class="keyword">for</span> this example.</span></span><br><span class="line">  read -n 1 -s -p $&#x27;Control-M leaves cursor at beginning of this line. Press Enter. \x0d&#x27;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 当然, <span class="string">&#x27;0d&#x27;</span>就是二进制的回车.</span></span><br><span class="line">  echo &gt;&amp;2   #  &#x27;-s&#x27;参数使得任何输入都不将回显出来.所以, 明确的重起一行是必要的.</span><br><span class="line">  read -n 1 -s -p $&#x27;Control-J leaves cursor on next line. \x0a&#x27;</span><br><span class="line"><span class="meta">  #</span><span class="bash">  <span class="string">&#x27;0a&#x27;</span> 等价于Control-J, 换行.</span></span><br><span class="line">  echo &gt;&amp;2</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">  </span><br><span class="line">  read -n 1 -s -p $&#x27;And Control-K\x0bgoes straight down.&#x27;</span><br><span class="line">  echo &gt;&amp;2   #  Control-K 是垂直制表符.</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 关于垂直制表符效果的一个更好的例子见下边:</span></span><br><span class="line">  var=$&#x27;\x0aThis is the bottom line\x0bThis is the top line\x0a&#x27;</span><br><span class="line">  echo &quot;$var&quot;</span><br><span class="line"><span class="meta">  #</span><span class="bash">  这句与上边的例子使用的是同样的办法, 然而:</span></span><br><span class="line">  echo &quot;$var&quot; | col</span><br><span class="line"><span class="meta">  #</span><span class="bash">  这将造成垂直制表符右边的部分比左边部分高.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  这也解释了为什么我们要在行首和行尾加上一个换行符 --这样可以避免屏幕显示混乱.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Lee Maschmeyer的解释:</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> -------------------------- </span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  在这里[第一个垂直制表符的例子中] . . .</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">+ 这个垂直制表符使得还没回车就直接打印下来.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  这只能在那些不能<span class="string">&quot;后退&quot;</span>的设备中才行,</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">+ 比如说Linux的console.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  垂直制表符的真正意义是向上移, 而不是向下.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  它可以用来让打印机打印上标.  </span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  col工具可以模拟垂直制表符的正确行为.</span></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ctl-Q恢复(XON).在一个终端中恢复<code>stdin</code>. </p>
</li>
<li><p>Ctl-S挂起(XOFF).在一个终端中冻结<code>stdin</code>.        (使用Ctl-Q可以恢复输入.)</p>
</li>
<li><p>Ctl-U删除光标到行首的所有字符.          在某些设置下,      <em>不管光标的所在位置</em>Ctl-U都将删除整行输入. </p>
</li>
<li><p>Ctl-V当输入字符时, Ctl-V允许插入控制字符.              比如, 下边的两个例子是等价的:          </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;\x0a&#x27;</span><br><span class="line">echo &lt;Ctl-V&gt;&lt;Ctl-J&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ctl-V主要用于文本编辑. </p>
<ul>
<li><p>Ctl-W当在控制台或一个xterm窗口敲入文本时,       Ctl-W将会删除当前光标到左边最近一个空格间的全部字符.        在某些设置下,        Ctl-W将会删除当前光标到左边第一个非字母或数字之间的全部字符. </p>
</li>
<li><p>Ctl-Z暂停前台作业.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空白</strong></p>
<ul>
<li>用来分隔函数, 命令或变量. .空白包含空格, tab, 空行, 或者是它们之间任意的组合体. 在某些上下文中,  比如[变量赋值],  空白是不被允许的, 会产生语法错误. </li>
<li>空行不会影响脚本的行为, 因此使用空行可以很好的划分独立的函数段以增加可读性. </li>
<li>特殊变量[$IFS]用来做一些输入命令的分隔符, 默认情况下是空白. </li>
<li>如果想在字符串或变量中使用空白, 那么应该使用[引用].</li>
</ul>
</li>
</ul>

</div>
        </div>
    

 

<footer>
    <div>© 2020 HanMingtao</div>
    <div>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></div>
</footer>
<div id="goto-top"><i class="icon-gototop"></i></div></body>
</html>